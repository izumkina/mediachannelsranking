<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Рейтинг качества медиа каналов</title>
    <script crossorigin src="https://unpkg.com/react@18/umd/react.development.js"></script>
    <script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.development.js"></script>
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/xlsx/0.18.5/xlsx.full.min.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background-color: #f5f5f5;
            color: #333;
            line-height: 1.6;
        }
        .container {
            max-width: 1400px;
            margin: 0 auto;
            padding: 20px;
        }
        .title {
            text-align: center;
            font-size: 32px;
            font-weight: bold;
            margin-bottom: 30px;
            color: #2c3e50;
        }
        .card {
            background: white;
            border-radius: 12px;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
            padding: 25px;
            margin-bottom: 25px;
        }
        .card-title {
            font-size: 20px;
            font-weight: 600;
            margin-bottom: 20px;
            color: #2c3e50;
        }
        .controls {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
            gap: 20px;
            margin-bottom: 20px;
        }
        .control-group {
            display: flex;
            flex-direction: column;
        }
        .label {
            font-weight: 600;
            margin-bottom: 8px;
            font-size: 14px;
            color: #555;
        }
        .select, .range-input {
            padding: 10px;
            border: 1px solid #ddd;
            border-radius: 6px;
            font-size: 14px;
            transition: border-color 0.2s;
        }
        .select:focus, .range-input:focus {
            outline: none;
            border-color: #3498db;
            box-shadow: 0 0 0 2px rgba(52, 152, 219, 0.2);
        }
        .rating-type-selector {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 15px;
            margin-bottom: 20px;
        }
        .rating-option {
            display: flex;
            align-items: center;
            padding: 12px;
            border: 2px solid #e9ecef;
            border-radius: 8px;
            cursor: pointer;
            transition: all 0.2s;
            background: white;
        }
        .rating-option.selected {
            border-color: #3498db;
            background: #e3f2fd;
        }
        .rating-option:hover {
            border-color: #3498db;
        }
        .rating-option input {
            margin-right: 10px;
            transform: scale(1.2);
        }
        .rating-option-label {
            flex: 1;
        }
        .rating-option-title {
            font-weight: 600;
            color: #2c3e50;
            font-size: 14px;
        }
        .rating-option-desc {
            font-size: 12px;
            color: #666;
            margin-top: 2px;
        }
        .channels-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 12px;
            margin-top: 15px;
        }
        .checkbox-label {
            display: flex;
            align-items: center;
            font-size: 13px;
            cursor: pointer;
            padding: 8px;
            border-radius: 6px;
            transition: background-color 0.2s;
        }
        .checkbox-label:hover {
            background-color: #f8f9fa;
        }
        .checkbox {
            margin-right: 8px;
            transform: scale(1.1);
        }
        .table {
            width: 100%;
            border-collapse: collapse;
            font-size: 14px;
        }
        .table th {
            background-color: #f8f9fa;
            padding: 12px 8px;
            text-align: left;
            font-weight: 600;
            color: #555;
            border-bottom: 2px solid #e9ecef;
        }
        .table td {
            padding: 12px 8px;
            border-bottom: 1px solid #e9ecef;
        }
        .table tbody tr:hover {
            background-color: #f8f9fa;
        }
        .table tbody tr:nth-child(even) {
            background-color: #fdfdfd;
        }
        .rank {
            font-weight: bold;
            color: #3498db;
        }
        .index-score {
            font-weight: bold;
            color: #27ae60;
            text-align: center;
        }
        .stats-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 20px;
        }
        .stat-card {
            text-align: center;
            padding: 20px;
            border-radius: 8px;
            border-left: 4px solid;
        }
        .stat-card.blue { background: #e3f2fd; border-color: #2196f3; }
        .stat-card.green { background: #e8f5e8; border-color: #4caf50; }
        .stat-card.orange { background: #fff3e0; border-color: #ff9800; }
        .stat-card.purple { background: #f3e5f5; border-color: #9c27b0; }
        .stat-value {
            font-size: 28px;
            font-weight: bold;
            margin-bottom: 5px;
        }
        .stat-value.blue { color: #2196f3; }
        .stat-value.green { color: #4caf50; }
        .stat-value.orange { color: #ff9800; }
        .stat-value.purple { color: #9c27b0; }
        .stat-label {
            font-size: 14px;
            color: #666;
        }
        .chart-container {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(500px, 1fr));
            gap: 25px;
        }
        .chart-card {
            background: white;
            border-radius: 12px;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
            padding: 25px;
        }
        .canvas-container {
            position: relative;
            height: 400px;
            margin: 20px 0;
        }
        canvas {
            border: 1px solid #e9ecef;
            border-radius: 8px;
        }
        .loading, .error {
            display: flex;
            justify-content: center;
            align-items: center;
            height: 100vh;
            flex-direction: column;
        }
        .loading {
            font-size: 20px;
            color: #666;
        }
        .error {
            background: #ffe6e6;
            color: #d32f2f;
            padding: 30px;
            border-radius: 12px;
            max-width: 600px;
            margin: 20px;
        }
        .error h3 {
            font-size: 24px;
            margin-bottom: 15px;
        }
        .error ul {
            text-align: left;
            margin: 15px 0;
        }
        .btn {
            background: #3498db;
            color: white;
            border: none;
            padding: 12px 24px;
            border-radius: 6px;
            cursor: pointer;
            font-size: 14px;
            font-weight: 600;
            margin-top: 15px;
            transition: background-color 0.2s;
        }
        .btn:hover {
            background: #2980b9;
        }
        .info-text {
            font-size: 14px;
            color: #666;
            text-align: center;
            margin-top: 10px;
        }
    </style>
</head>
<body>
    <div id="root"></div>

    <script type="text/babel">
        const { useState, useEffect, useMemo, useRef } = React;

        // Компонент для столбчатой диаграммы
        const BarChart = ({ data, width = 600, height = 400, ratingType }) => {
            const canvasRef = useRef(null);

            useEffect(() => {
                const canvas = canvasRef.current;
                if (!canvas || !data || data.length === 0) return;

                const ctx = canvas.getContext('2d');
                const padding = 60;
                const chartWidth = width - padding * 2;
                const chartHeight = height - padding * 2;

                ctx.clearRect(0, 0, width, height);

                const maxValue = Math.max(...data.map(d => d.ratingValue));
                const barWidth = chartWidth / data.length * 0.8;
                const barSpacing = chartWidth / data.length * 0.2;

                data.forEach((item, index) => {
                    const barHeight = (item.ratingValue / maxValue) * chartHeight;
                    const x = padding + index * (barWidth + barSpacing);
                    const y = height - padding - barHeight;

                    const gradient = ctx.createLinearGradient(0, y, 0, y + barHeight);
                    
                    if (ratingType === 'general') {
                        gradient.addColorStop(0, '#3498db');
                        gradient.addColorStop(1, '#2980b9');
                    } else if (ratingType === 'brand') {
                        gradient.addColorStop(0, '#e74c3c');
                        gradient.addColorStop(1, '#c0392b');
                    } else {
                        gradient.addColorStop(0, '#2ecc71');
                        gradient.addColorStop(1, '#27ae60');
                    }

                    ctx.fillStyle = gradient;
                    ctx.fillRect(x, y, barWidth, barHeight);

                    ctx.fillStyle = '#2c3e50';
                    ctx.font = '12px Arial';
                    ctx.textAlign = 'center';
                    ctx.fillText(item.ratingValue.toFixed(2), x + barWidth/2, y - 5);

                    ctx.save();
                    ctx.translate(x + barWidth/2, height - padding + 15);
                    ctx.rotate(-Math.PI/4);
                    ctx.textAlign = 'right';
                    ctx.fillStyle = '#666';
                    ctx.font = '10px Arial';
                    const shortName = item.name.length > 15 ? item.name.substring(0, 15) + '...' : item.name;
                    ctx.fillText(shortName, 0, 0);
                    ctx.restore();
                });

                ctx.strokeStyle = '#ddd';
                ctx.lineWidth = 1;
                ctx.beginPath();
                ctx.moveTo(padding, padding);
                ctx.lineTo(padding, height - padding);
                ctx.moveTo(padding, height - padding);
                ctx.lineTo(width - padding, height - padding);
                ctx.stroke();

            }, [data, width, height, ratingType]);

            return <canvas ref={canvasRef} width={width} height={height} />;
        };

        // Радарная диаграмма для топ-5
        const RadarChart = ({ data, width = 600, height = 400 }) => {
            const canvasRef = useRef(null);

            useEffect(() => {
                const canvas = canvasRef.current;
                if (!canvas || !data || data.length === 0) return;

                const ctx = canvas.getContext('2d');
                const centerX = width / 2;
                const centerY = height / 2;
                const maxRadius = Math.min(width, height) / 2 - 80;

                ctx.clearRect(0, 0, width, height);

                const criteria = [
                    'Trust',
                    'Active Consumption', 
                    'Format Effect',
                    'Image Size',
                    'Contact Time',
                    'Momentary Clutter',
                    'Personalization',
                    'Targeting Accuracy',
                    'CJ Targeting'
                ];

                const angleStep = (Math.PI * 2) / criteria.length;
                const colors = [
                    '#3498db',
                    '#2ecc71',
                    '#f39c12',
                    '#e74c3c',
                    '#9b59b6'
                ];

                ctx.strokeStyle = '#e0e0e0';
                ctx.lineWidth = 1;
                for (let i = 1; i <= 5; i++) {
                    ctx.beginPath();
                    ctx.arc(centerX, centerY, (maxRadius * i) / 5, 0, Math.PI * 2);
                    ctx.stroke();
                }

                ctx.strokeStyle = '#ccc';
                ctx.fillStyle = '#555';
                ctx.font = '12px Arial';
                ctx.textAlign = 'center';

                criteria.forEach((criterion, index) => {
                    const angle = index * angleStep - Math.PI / 2;
                    const x1 = centerX;
                    const y1 = centerY;
                    const x2 = centerX + Math.cos(angle) * maxRadius;
                    const y2 = centerY + Math.sin(angle) * maxRadius;

                    ctx.beginPath();
                    ctx.moveTo(x1, y1);
                    ctx.lineTo(x2, y2);
                    ctx.stroke();

                    const labelX = centerX + Math.cos(angle) * (maxRadius + 20);
                    const labelY = centerY + Math.sin(angle) * (maxRadius + 20);
                    ctx.fillText(criterion, labelX, labelY + 4);
                });

                const top5 = data.slice(0, 5);
                
                top5.forEach((item, itemIndex) => {
                    if (itemIndex >= colors.length) return;
                    
                    const values = [
                        item.trust || 0,
                        item.passiveConsumption || 0,
                        item.formatScore || 0,
                        item.attentionShare || 0,
                        item.contactTime || 0,
                        item.momentaryClutter || 0,
                        item.personalization || 0,
                        item.targetingAccuracy || 0,
                        item.cjTargeting || 0
                    ];

                    const points = values.map((value, index) => {
                        const angle = index * angleStep - Math.PI / 2;
                        const radius = Math.min(value, 1) * maxRadius;
                        return {
                            x: centerX + Math.cos(angle) * radius,
                            y: centerY + Math.sin(angle) * radius
                        };
                    });

                    ctx.fillStyle = colors[itemIndex] + '20';
                    ctx.beginPath();
                    ctx.moveTo(points[0].x, points[0].y);
                    for (let i = 1; i < points.length; i++) {
                        ctx.lineTo(points[i].x, points[i].y);
                    }
                    ctx.closePath();
                    ctx.fill();

                    ctx.strokeStyle = colors[itemIndex];
                    ctx.lineWidth = 2;
                    ctx.stroke();

                    ctx.fillStyle = colors[itemIndex];
                    points.forEach(point => {
                        ctx.beginPath();
                        ctx.arc(point.x, point.y, 4, 0, Math.PI * 2);
                        ctx.fill();
                    });
                });

                const legendX = 20;
                let legendY = height - 120;
                
                ctx.font = '12px Arial';
                ctx.textAlign = 'left';
                ctx.fillStyle = '#333';
                ctx.fillText('Легенда:', legendX, legendY);
                legendY += 20;

                top5.forEach((item, index) => {
                    if (index >= colors.length) return;
                    
                    ctx.fillStyle = colors[index];
                    ctx.fillRect(legendX, legendY - 8, 12, 12);
                    
                    ctx.fillStyle = '#333';
                    const shortName = item.name.length > 25 ? item.name.substring(0, 25) + '...' : item.name;
                    ctx.fillText(shortName, legendX + 20, legendY + 2);
                    legendY += 18;
                });

            }, [data, width, height]);

            return <canvas ref={canvasRef} width={width} height={height} />;
        };

        // Главный компонент
        const MediaRatingDashboard = () => {
            const [data, setData] = useState([]);
            const [loading, setLoading] = useState(true);
            const [error, setError] = useState(null);
            const [viewMode, setViewMode] = useState('channels');
            const [ratingType, setRatingType] = useState('general');
            const [selectedChannels, setSelectedChannels] = useState([]);
            const [availableChannels, setAvailableChannels] = useState([]);
            const [displayCount, setDisplayCount] = useState(10);

            useEffect(() => {
                const loadData = async () => {
                    try {
                        console.log('Начинаем загрузку Excel файла...');
                        
                        let response;
                        let arrayBuffer;
                        
                        try {
                            response = await fetch('./calc_mts_v18_processed.xlsx');
                            if (response.ok) {
                                arrayBuffer = await response.arrayBuffer();
                                console.log('Файл загружен через fetch');
                            } else {
                                throw new Error(`HTTP ${response.status}: ${response.statusText}`);
                            }
                        } catch (fetchError) {
                            console.log('Fetch не сработал:', fetchError.message);
                            
                            if (typeof window !== 'undefined' && window.fs && window.fs.readFile) {
                                console.log('Пробуем window.fs.readFile...');
                                const fileData = await window.fs.readFile('calc_mts_v18_processed.xlsx');
                                arrayBuffer = fileData.buffer || fileData;
                                console.log('Файл загружен через window.fs');
                            } else {
                                throw new Error('Excel файл не найден. Убедитесь, что файл calc_mts_v18_processed.xlsx находится в той же папке что и index.html');
                            }
                        }
                        
                        console.log(`Размер файла: ${arrayBuffer.byteLength} байт`);
                        
                        const workbook = XLSX.read(arrayBuffer, {
                            cellStyles: true,
                            cellFormulas: true,
                            cellDates: true
                        });
                        
                        console.log('Листы в файле:', workbook.SheetNames);
                        
                        const firstSheet = workbook.Sheets[workbook.SheetNames[0]];
                        const rawData = XLSX.utils.sheet_to_json(firstSheet, {header: 1});
                        
                        console.log(`Строк данных: ${rawData.length}`);
                        
                        const processedData = rawData.slice(1).map((row, index) => ({
                            channel: row[0],
                            format: row[1], 
                            duration: row[2],
                            trust: row[21] || 0,
                            passiveConsumption: row[22] || 0,
                            formatScore: row[24] || 0,
                            attentionShare: row[25] || 0,
                            contactTime: row[26] || 0,
                            momentaryClutter: row[27] || 0,
                            personalization: row[39] || 0,
                            targetingAccuracy: row[40] || 0,
                            cjTargeting: row[41] || 0,
                            integralIndex: row[30] || 0,
                            brandIndex: row[51] || 0,
                            purchaseIndex: row[52] || 0
                        })).filter(item => item.channel && item.channel !== '');

                        console.log(`Обработанных записей: ${processedData.length}`);
                        
                        setData(processedData);
                        
                        const channels = [...new Set(processedData.map(item => item.channel))];
                        console.log(`Уникальных каналов: ${channels.length}`);
                        setAvailableChannels(channels);
                        setSelectedChannels(channels.slice(0, 5));
                        
                        setLoading(false);
                        console.log('Данные успешно загружены!');
                        
                    } catch (error) {
                        console.error('Ошибка загрузки:', error);
                        setError(error.message);
                        setLoading(false);
                    }
                };
                
                loadData();
            }, []);

            const processedData = useMemo(() => {
                let filtered = data.filter(item => selectedChannels.includes(item.channel));
                
                const getRatingValue = (item) => {
                    switch (ratingType) {
                        case 'brand': return item.brandIndex;
                        case 'purchase': return item.purchaseIndex;
                        default: return item.integralIndex;
                    }
                };
                
                if (viewMode === 'channels') {
                    const channelGroups = {};
                    filtered.forEach(item => {
                        if (!channelGroups[item.channel]) {
                            channelGroups[item.channel] = {
                                channel: item.channel,
                                integralIndex: [],
                                brandIndex: [],
                                purchaseIndex: [],
                                trust: [],
                                passiveConsumption: [],
                                formatScore: [],
                                attentionShare: [],
                                contactTime: [],
                                momentaryClutter: [],
                                personalization: [],
                                targetingAccuracy: [],
                                cjTargeting: []
                            };
                        }
                        channelGroups[item.channel].integralIndex.push(item.integralIndex);
                        channelGroups[item.channel].brandIndex.push(item.brandIndex);
                        channelGroups[item.channel].purchaseIndex.push(item.purchaseIndex);
                        channelGroups[item.channel].trust.push(item.trust);
                        channelGroups[item.channel].passiveConsumption.push(item.passiveConsumption);
                        channelGroups[item.channel].formatScore.push(item.formatScore);
                        channelGroups[item.channel].attentionShare.push(item.attentionShare);
                        channelGroups[item.channel].contactTime.push(item.contactTime);
                        channelGroups[item.channel].momentaryClutter.push(item.momentaryClutter);
                        channelGroups[item.channel].personalization.push(item.personalization);
                        channelGroups[item.channel].targetingAccuracy.push(item.targetingAccuracy);
                        channelGroups[item.channel].cjTargeting.push(item.cjTargeting);
                    });
                    
                    const aggregated = Object.values(channelGroups).map(group => {
                        const item = {
                            name: group.channel,
                            channel: group.channel,
                            integralIndex: group.integralIndex.reduce((a, b) => a + b, 0) / group.integralIndex.length,
                            brandIndex: group.brandIndex.reduce((a, b) => a + b, 0) / group.brandIndex.length,
                            purchaseIndex: group.purchaseIndex.reduce((a, b) => a + b, 0) / group.purchaseIndex.length,
                            trust: group.trust.reduce((a, b) => a + b, 0) / group.trust.length,
                            passiveConsumption: group.passiveConsumption.reduce((a, b) => a + b, 0) / group.passiveConsumption.length,
                            formatScore: group.formatScore.reduce((a, b) => a + b, 0) / group.formatScore.length,
                            attentionShare: group.attentionShare.reduce((a, b) => a + b, 0) / group.attentionShare.length,
                            contactTime: group.contactTime.reduce((a, b) => a + b, 0) / group.contactTime.length,
                            momentaryClutter: group.momentaryClutter.reduce((a, b) => a + b, 0) / group.momentaryClutter.length,
                            personalization: group.personalization.reduce((a, b) => a + b, 0) / group.personalization.length,
                            targetingAccuracy: group.targetingAccuracy.reduce((a, b) => a + b, 0) / group.targetingAccuracy.length,
                            cjTargeting: group.cjTargeting.reduce((a, b) => a + b, 0) / group.cjTargeting.length
                        };
                        item.ratingValue = getRatingValue(item);
                        return item;
                    });
                    
                    return aggregated
                        .sort((a, b) => b.ratingValue - a.ratingValue)
                        .slice(0, displayCount);
                        
                } else if (viewMode === 'channel-format') {
                    const channelFormatGroups = {};
                    filtered.forEach(item => {
                        const key = `${item.channel} - ${item.format}`;
                        if (!channelFormatGroups[key]) {
                            channelFormatGroups[key] = {
                                channel: item.channel,
                                format: item.format,
                                name: key,
                                integralIndex: [],
                                brandIndex: [],
                                purchaseIndex: [],
                                trust: [],
                                passiveConsumption: [],
                                formatScore: [],
                                attentionShare: [],
                                contactTime: [],
                                momentaryClutter: [],
                                personalization: [],
                                targetingAccuracy: [],
                                cjTargeting: []
                            };
                        }
                        channelFormatGroups[key].integralIndex.push(item.integralIndex);
                        channelFormatGroups[key].brandIndex.push(item.brandIndex);
                        channelFormatGroups[key].purchaseIndex.push(item.purchaseIndex);
                        channelFormatGroups[key].trust.push(item.trust);
                        channelFormatGroups[key].passiveConsumption.push(item.passiveConsumption);
                        channelFormatGroups[key].formatScore.push(item.formatScore);
                        channelFormatGroups[key].attentionShare.push(item.attentionShare);
                        channelFormatGroups[key].contactTime.push(item.contactTime);
                        channelFormatGroups[key].momentaryClutter.push(item.momentaryClutter);
                        channelFormatGroups[key].personalization.push(item.personalization);
                        channelFormatGroups[key].targetingAccuracy.push(item.targetingAccuracy);
                        channelFormatGroups[key].cjTargeting.push(item.cjTargeting);
                    });
                    
                    const aggregated = Object.values(channelFormatGroups).map(group => {
                        const item = {
                            name: group.name,
                            channel: group.channel,
                            format: group.format,
                            integralIndex: group.integralIndex.reduce((a, b) => a + b, 0) / group.integralIndex.length,
                            brandIndex: group.brandIndex.reduce((a, b) => a + b, 0) / group.brandIndex.length,
                            purchaseIndex: group.purchaseIndex.reduce((a, b) => a + b, 0) / group.purchaseIndex.length,
                            trust: group.trust.reduce((a, b) => a + b, 0) / group.trust.length,
                            passiveConsumption: group.passiveConsumption.reduce((a, b) => a + b, 0) / group.passiveConsumption.length,
                            formatScore: group.formatScore.reduce((a, b) => a + b, 0) / group.formatScore.length,
                            attentionShare: group.attentionShare.reduce((a, b) => a + b, 0) / group.attentionShare.length,
                            contactTime: group.contactTime.reduce((a, b) => a + b, 0) / group.contactTime.length,
                            momentaryClutter: group.momentaryClutter.reduce((a, b) => a + b, 0) / group.momentaryClutter.length,
                            personalization: group.personalization.reduce((a, b) => a + b, 0) / group.personalization.length,
                            targetingAccuracy: group.targetingAccuracy.reduce((a, b) => a + b, 0) / group.targetingAccuracy.length,
                            cjTargeting: group.cjTargeting.reduce((a, b) => a + b, 0) / group.cjTargeting.length
                        };
                        item.ratingValue = getRatingValue(item);
                        return item;
                    });
                    
                    return aggregated
                        .sort((a, b) => b.ratingValue - a.ratingValue)
                        .slice(0, displayCount);
                } else {
                    const result = filtered
                        .map(item => {
                            const newItem = {
                                ...item,
                                name: `${item.channel} - ${item.format} (${item.duration}s)`
                            };
                            newItem.ratingValue = getRatingValue(newItem);
                            return newItem;
                        })
                        .sort((a, b) => b.ratingValue - a.ratingValue)
                        .slice(0, displayCount);
                    return result;
                }
            }, [data, selectedChannels, viewMode, displayCount, ratingType]);

            const handleChannelToggle = (channel) => {
                setSelectedChannels(prev => 
                    prev.includes(channel) 
                        ? prev.filter(c => c !== channel)
                        : [...prev, channel]
                );
            };

            const getRatingTypeLabel = () => {
                switch (ratingType) {
                    case 'brand': return 'Рейтинг по бренд-метрикам';
                    case 'purchase': return 'Рейтинг по намерению покупки';
                    default: return 'Общий интегральный рейтинг';
                }
            };

            if (loading) {
                return (
                    <div className="loading">
                        <div style={{fontSize: '24px', marginBottom: '10px'}}>Загрузка данных...</div>
                        <div style={{fontSize: '16px', color: '#666'}}>Читаем Excel файл calc_mts_v18_processed.xlsx</div>
                    </div>
                );
            }

            if (error) {
                return (
                    <div className="error">
                        <h3>Ошибка загрузки данных</h3>
                        <p><strong>Проблема:</strong> {error}</p>
                        <div>
                            <p><strong>Возможные решения:</strong></p>
                            <ul>
                                <li>Убедитесь что файл <code>calc_mts_v18_processed.xlsx</code> загружен в GitHub</li>
                                <li>Файл должен быть в той же папке что и <code>index.html</code></li>
                                <li>Проверьте точность названия файла</li>
                                <li>Возможно нужно подождать несколько минут для обновления GitHub Pages</li>
                            </ul>
                        </div>
                        <button className="btn" onClick={() => window.location.reload()}>
                            Попробовать снова
                        </button>
                    </div>
                );
            }

            return (
                <div className="container">
                    <h1 className="title">Рейтинг качества медиа каналов</h1>
                    
                    <div className="card">
                        <div className="card-title">Настройки отображения</div>
                        
                        <div>
                            <label className="label">Тип рейтинга:</label>
                            <div className="rating-type-selector">
                                <label className={`rating-option ${ratingType === 'general' ? 'selected' : ''}`}>
                                    <input
                                        type="radio"
                                        name="ratingType"
                                        value="general"
                                        checked={ratingType === 'general'}
                                        onChange={(e) => setRatingType(e.target.value)}
                                    />
                                    <div className="rating-option-label">
                                        <div className="rating-option-title">Общий рейтинг</div>
                                        <div className="rating-option-desc">Интегральный индекс качества</div>
                                    </div>
                                </label>
                                
                                <label className={`rating-option ${ratingType === 'brand' ? 'selected' : ''}`}>
                                    <input
                                        type="radio"
                                        name="ratingType"
                                        value="brand"
                                        checked={ratingType === 'brand'}
                                        onChange={(e) => setRatingType(e.target.value)}
                                    />
                                    <div className="rating-option-label">
                                        <div className="rating-option-title">Бренд-метрики</div>
                                        <div className="rating-option-desc">Индекс для брендинга</div>
                                    </div>
                                </label>
                                
                                <label className={`rating-option ${ratingType === 'purchase' ? 'selected' : ''}`}>
                                    <input
                                        type="radio"
                                        name="ratingType"
                                        value="purchase"
                                        checked={ratingType === 'purchase'}
                                        onChange={(e) => setRatingType(e.target.value)}
                                    />
                                    <div className="rating-option-label">
                                        <div className="rating-option-title">Намерение покупки</div>
                                        <div className="rating-option-desc">Индекс для конверсии</div>
                                    </div>
                                </label>
                            </div>
                        </div>

                        <div className="controls">
                            <div className="control-group">
                                <label className="label">Режим отображения:</label>
                                <select 
                                    className="select"
                                    value={viewMode} 
                                    onChange={(e) => setViewMode(e.target.value)}
                                >
                                    <option value="channels">Только каналы</option>
                                    <option value="channel-format">Канал + Формат</option>
                                    <option value="channel-format-duration">Канал + Формат + Длительность</option>
                                </select>
                            </div>
                            
                            <div className="control-group">
                                <label className="label">Количество элементов: {displayCount}</label>
                                <input
                                    className="range-input"
                                    type="range"
                                    min="5"
                                    max="30"
                                    value={displayCount}
                                    onChange={(e) => setDisplayCount(parseInt(e.target.value))}
                                />
                            </div>
                            
                            <div className="control-group">
                                <div className="info-text">
                                    Показано: {Math.min(displayCount, processedData.length)} из {processedData.length}<br/>
                                    Всего записей: {data.length}
                                </div>
                            </div>
                        </div>

                        <div>
                            <label className="label">Выберите каналы:</label>
                            <div className="channels-grid">
                                {availableChannels.map(channel => (
                                    <label key={channel} className="checkbox-label">
                                        <input
                                            className="checkbox"
                                            type="checkbox"
                                            checked={selectedChannels.includes(channel)}
                                            onChange={() => handleChannelToggle(channel)}
                                        />
                                        <span title={channel}>{channel}</span>
                                    </label>
                                ))}
                            </div>
                        </div>
                    </div>

                    <div className="card">
                        <h2 className="card-title">{getRatingTypeLabel()}</h2>
                        <div style={{overflowX: 'auto'}}>
                            <table className="table">
                                <thead>
                                    <tr>
                                        <th>Рейтинг</th>
                                        <th>Название</th>
                                        <th style={{textAlign: 'center'}}>Значение индекса</th>
                                    </tr>
                                </thead>
                                <tbody>
                                    {processedData.map((item, index) => (
                                        <tr key={index}>
                                            <td className="rank">#{index + 1}</td>
                                            <td>{item.name}</td>
                                            <td className="index-score">
                                                {item.ratingValue.toFixed(2)}
                                            </td>
                                        </tr>
                                    ))}
                                </tbody>
                            </table>
                        </div>
                    </div>

                    <div className="chart-container">
                        <div className="chart-card">
                            <h2 className="card-title">{getRatingTypeLabel()}</h2>
                            <div className="canvas-container">
                                <BarChart 
                                    data={processedData} 
                                    width={600} 
                                    height={400} 
                                    ratingType={ratingType}
                                />
                            </div>
                        </div>
                        
                        <div className="chart-card">
                            <h2 className="card-title">Сравнение топ-5 по критериям</h2>
                            <div className="canvas-container">
                                <RadarChart data={processedData} width={600} height={400} />
                            </div>
                        </div>
                    </div>

                    <div className="card">
                        <h2 className="card-title">Статистика</h2>
                        <div className="stats-grid">
                            <div className="stat-card blue">
                                <div className="stat-value blue">
                                    {selectedChannels.length}
                                </div>
                                <div className="stat-label">Выбрано каналов</div>
                            </div>
                            <div className="stat-card green">
                                <div className="stat-value green">
                                    {data.filter(item => selectedChannels.includes(item.channel)).length}
                                </div>
                                <div className="stat-label">Всего записей</div>
                            </div>
                            <div className="stat-card orange">
                                <div className="stat-value orange">
                                    {processedData.length > 0 ? processedData[0].ratingValue.toFixed(2) : '0.00'}
                                </div>
                                <div className="stat-label">Лучший рейтинг</div>
                            </div>
                            <div className="stat-card purple">
                                <div className="stat-value purple">
                                    {processedData.length > 0 ? 
                                        (processedData.reduce((sum, item) => sum + item.ratingValue, 0) / processedData.length).toFixed(2) 
                                        : '0.00'}
                                </div>
                                <div className="stat-label">Средний рейтинг</div>
                            </div>
                        </div>
                    </div>
                </div>
            );
        };

        ReactDOM.render(React.createElement(MediaRatingDashboard), document.getElementById('root'));
    </script>
</body>
</html>