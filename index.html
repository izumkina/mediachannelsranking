<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>–†–µ–π—Ç–∏–Ω–≥ –∫–∞—á–µ—Å—Ç–≤–∞ –º–µ–¥–∏–∞ –∫–∞–Ω–∞–ª–æ–≤</title>
    <script crossorigin src="https://unpkg.com/react@18/umd/react.development.js"></script>
    <script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.development.js"></script>
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/xlsx/0.18.5/xlsx.full.min.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background-color: #f5f5f5;
            color: #333;
            line-height: 1.6;
        }
        .container {
            max-width: 1400px;
            margin: 0 auto;
            padding: 20px;
        }
        .title {
            text-align: center;
            font-size: 32px;
            font-weight: bold;
            margin-bottom: 30px;
            color: #2c3e50;
        }
        .card {
            background: white;
            border-radius: 12px;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
            padding: 25px;
            margin-bottom: 25px;
        }
        .card-title {
            font-size: 20px;
            font-weight: 600;
            margin-bottom: 20px;
            color: #2c3e50;
        }
        .controls {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
            gap: 20px;
            margin-bottom: 20px;
        }
        .control-group {
            display: flex;
            flex-direction: column;
        }
        .label {
            font-weight: 600;
            margin-bottom: 8px;
            font-size: 14px;
            color: #555;
        }
        .select, .range-input {
            padding: 10px;
            border: 1px solid #ddd;
            border-radius: 6px;
            font-size: 14px;
            transition: border-color 0.2s;
        }
        .select:focus, .range-input:focus {
            outline: none;
            border-color: #3498db;
            box-shadow: 0 0 0 2px rgba(52, 152, 219, 0.2);
        }
        .channels-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 12px;
            margin-top: 15px;
        }
        .checkbox-label {
            display: flex;
            align-items: center;
            font-size: 13px;
            cursor: pointer;
            padding: 8px;
            border-radius: 6px;
            transition: background-color 0.2s;
        }
        .checkbox-label:hover {
            background-color: #f8f9fa;
        }
        .checkbox {
            margin-right: 8px;
            transform: scale(1.1);
        }
        .table {
            width: 100%;
            border-collapse: collapse;
            font-size: 14px;
        }
        .table th {
            background-color: #f8f9fa;
            padding: 12px 8px;
            text-align: left;
            font-weight: 600;
            color: #555;
            border-bottom: 2px solid #e9ecef;
        }
        .table td {
            padding: 12px 8px;
            border-bottom: 1px solid #e9ecef;
        }
        .table tbody tr:hover {
            background-color: #f8f9fa;
        }
        .table tbody tr:nth-child(even) {
            background-color: #fdfdfd;
        }
        .rank {
            font-weight: bold;
            color: #3498db;
        }
        .index-score {
            font-weight: bold;
            color: #27ae60;
            text-align: center;
        }
        .stats-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 20px;
        }
        .stat-card {
            text-align: center;
            padding: 20px;
            border-radius: 8px;
            border-left: 4px solid;
        }
        .stat-card.blue { background: #e3f2fd; border-color: #2196f3; }
        .stat-card.green { background: #e8f5e8; border-color: #4caf50; }
        .stat-card.orange { background: #fff3e0; border-color: #ff9800; }
        .stat-card.purple { background: #f3e5f5; border-color: #9c27b0; }
        .stat-value {
            font-size: 28px;
            font-weight: bold;
            margin-bottom: 5px;
        }
        .stat-value.blue { color: #2196f3; }
        .stat-value.green { color: #4caf50; }
        .stat-value.orange { color: #ff9800; }
        .stat-value.purple { color: #9c27b0; }
        .stat-label {
            font-size: 14px;
            color: #666;
        }
        .chart-container {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(500px, 1fr));
            gap: 25px;
        }
        .chart-card {
            background: white;
            border-radius: 12px;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
            padding: 25px;
        }
        .canvas-container {
            position: relative;
            height: 400px;
            margin: 20px 0;
        }
        canvas {
            border: 1px solid #e9ecef;
            border-radius: 8px;
        }
        .loading, .error {
            display: flex;
            justify-content: center;
            align-items: center;
            height: 100vh;
            flex-direction: column;
        }
        .loading {
            font-size: 20px;
            color: #666;
        }
        .error {
            background: #ffe6e6;
            color: #d32f2f;
            padding: 30px;
            border-radius: 12px;
            max-width: 600px;
            margin: 20px;
        }
        .error h3 {
            font-size: 24px;
            margin-bottom: 15px;
        }
        .error ul {
            text-align: left;
            margin: 15px 0;
        }
        .btn {
            background: #3498db;
            color: white;
            border: none;
            padding: 12px 24px;
            border-radius: 6px;
            cursor: pointer;
            font-size: 14px;
            font-weight: 600;
            margin-top: 15px;
            transition: background-color 0.2s;
        }
        .btn:hover {
            background: #2980b9;
        }
        .info-text {
            font-size: 14px;
            color: #666;
            text-align: center;
            margin-top: 10px;
        }
    </style>
</head>
<body>
    <div id="root"></div>

    <script type="text/babel">
        const { useState, useEffect, useMemo, useRef } = React;

        // –ü—Ä–æ—Å—Ç–æ–π –∫–æ–º–ø–æ–Ω–µ–Ω—Ç –¥–ª—è —Å—Ç–æ–ª–±—á–∞—Ç–æ–π –¥–∏–∞–≥—Ä–∞–º–º—ã
        const BarChart = ({ data, width = 600, height = 400 }) => {
            const canvasRef = useRef(null);

            useEffect(() => {
                const canvas = canvasRef.current;
                if (!canvas || !data || data.length === 0) return;

                const ctx = canvas.getContext('2d');
                const padding = 60;
                const chartWidth = width - padding * 2;
                const chartHeight = height - padding * 2;

                // –û—á–∏—â–∞–µ–º canvas
                ctx.clearRect(0, 0, width, height);

                // –ù–∞—Ö–æ–¥–∏–º –º–∞–∫—Å–∏–º–∞–ª—å–Ω–æ–µ –∑–Ω–∞—á–µ–Ω–∏–µ
                const maxValue = Math.max(...data.map(d => d.integralIndex));
                const barWidth = chartWidth / data.length * 0.8;
                const barSpacing = chartWidth / data.length * 0.2;

                // –†–∏—Å—É–µ–º —Å—Ç–æ–ª–±—Ü—ã
                data.forEach((item, index) => {
                    const barHeight = (item.integralIndex / maxValue) * chartHeight;
                    const x = padding + index * (barWidth + barSpacing);
                    const y = height - padding - barHeight;

                    // –ì—Ä–∞–¥–∏–µ–Ω—Ç –¥–ª—è —Å—Ç–æ–ª–±—Ü–∞
                    const gradient = ctx.createLinearGradient(0, y, 0, y + barHeight);
                    gradient.addColorStop(0, '#3498db');
                    gradient.addColorStop(1, '#2980b9');

                    ctx.fillStyle = gradient;
                    ctx.fillRect(x, y, barWidth, barHeight);

                    // –ó–Ω–∞—á–µ–Ω–∏–µ –Ω–∞–¥ —Å—Ç–æ–ª–±—Ü–æ–º
                    ctx.fillStyle = '#2c3e50';
                    ctx.font = '12px Arial';
                    ctx.textAlign = 'center';
                    ctx.fillText(item.integralIndex.toFixed(3), x + barWidth/2, y - 5);

                    // –ù–∞–∑–≤–∞–Ω–∏–µ –ø–æ–¥ —Å—Ç–æ–ª–±—Ü–æ–º (—Å–æ–∫—Ä–∞—â–µ–Ω–Ω–æ–µ)
                    ctx.save();
                    ctx.translate(x + barWidth/2, height - padding + 15);
                    ctx.rotate(-Math.PI/4);
                    ctx.textAlign = 'right';
                    ctx.fillStyle = '#666';
                    ctx.font = '10px Arial';
                    const shortName = item.name.length > 15 ? item.name.substring(0, 15) + '...' : item.name;
                    ctx.fillText(shortName, 0, 0);
                    ctx.restore();
                });

                // –û—Å–∏
                ctx.strokeStyle = '#ddd';
                ctx.lineWidth = 1;
                ctx.beginPath();
                // Y-–æ—Å—å
                ctx.moveTo(padding, padding);
                ctx.lineTo(padding, height - padding);
                // X-–æ—Å—å
                ctx.moveTo(padding, height - padding);
                ctx.lineTo(width - padding, height - padding);
                ctx.stroke();

            }, [data, width, height]);

            return <canvas ref={canvasRef} width={width} height={height} />;
        };

        // –ö—Ä–∞—Å–∏–≤–∞—è —Ä–∞–¥–∞—Ä–Ω–∞—è –¥–∏–∞–≥—Ä–∞–º–º–∞ (–∑–≤–µ–∑–¥–æ—á–∫–∞) –¥–ª—è —Ç–æ–ø-5
        const RadarChart = ({ data, width = 600, height = 400 }) => {
            const canvasRef = useRef(null);

            useEffect(() => {
                const canvas = canvasRef.current;
                if (!canvas || !data || data.length === 0) return;

                const ctx = canvas.getContext('2d');
                const centerX = width / 2;
                const centerY = height / 2;
                const maxRadius = Math.min(width, height) / 2 - 80;

                // –û—á–∏—â–∞–µ–º canvas
                ctx.clearRect(0, 0, width, height);

                // –ö—Ä–∏—Ç–µ—Ä–∏–∏ –æ—Ü–µ–Ω–∫–∏
                const criteria = [
                    'Trust',
                    'Passive Consumption', 
                    'Format',
                    'Attention Share',
                    'Contact Time',
                    'Momentary Clutter'
                ];

                const angleStep = (Math.PI * 2) / criteria.length;
                const colors = [
                    '#3498db', // –°–∏–Ω–∏–π
                    '#2ecc71', // –ó–µ–ª–µ–Ω—ã–π  
                    '#f39c12', // –û—Ä–∞–Ω–∂–µ–≤—ã–π
                    '#e74c3c', // –ö—Ä–∞—Å–Ω—ã–π
                    '#9b59b6'  // –§–∏–æ–ª–µ—Ç–æ–≤—ã–π
                ];

                // –†–∏—Å—É–µ–º –∫–æ–Ω—Ü–µ–Ω—Ç—Ä–∏—á–µ—Å–∫–∏–µ –æ–∫—Ä—É–∂–Ω–æ—Å—Ç–∏ (—Å–µ—Ç–∫—É)
                ctx.strokeStyle = '#e0e0e0';
                ctx.lineWidth = 1;
                for (let i = 1; i <= 5; i++) {
                    ctx.beginPath();
                    ctx.arc(centerX, centerY, (maxRadius * i) / 5, 0, Math.PI * 2);
                    ctx.stroke();
                }

                // –†–∏—Å—É–µ–º –æ—Å–∏ –∏ –ø–æ–¥–ø–∏—Å–∏ –∫—Ä–∏—Ç–µ—Ä–∏–µ–≤
                ctx.strokeStyle = '#ccc';
                ctx.fillStyle = '#555';
                ctx.font = '12px Arial';
                ctx.textAlign = 'center';

                criteria.forEach((criterion, index) => {
                    const angle = index * angleStep - Math.PI / 2;
                    const x1 = centerX;
                    const y1 = centerY;
                    const x2 = centerX + Math.cos(angle) * maxRadius;
                    const y2 = centerY + Math.sin(angle) * maxRadius;

                    // –õ–∏–Ω–∏—è –æ—Å–∏
                    ctx.beginPath();
                    ctx.moveTo(x1, y1);
                    ctx.lineTo(x2, y2);
                    ctx.stroke();

                    // –ü–æ–¥–ø–∏—Å—å –∫—Ä–∏—Ç–µ—Ä–∏—è
                    const labelX = centerX + Math.cos(angle) * (maxRadius + 20);
                    const labelY = centerY + Math.sin(angle) * (maxRadius + 20);
                    ctx.fillText(criterion, labelX, labelY + 4);
                });

                // –†–∏—Å—É–µ–º –∑–Ω–∞—á–µ–Ω–∏—è –¥–ª—è —Ç–æ–ø-5 —ç–ª–µ–º–µ–Ω—Ç–æ–≤
                const top5 = data.slice(0, 5);
                
                top5.forEach((item, itemIndex) => {
                    if (itemIndex >= colors.length) return;
                    
                    const values = [
                        item.trust || 0,
                        item.passiveConsumption || 0,
                        item.formatScore || 0,
                        item.attentionShare || 0,
                        item.contactTime || 0,
                        item.momentaryClutter || 0
                    ];

                    // –ù–æ—Ä–º–∞–ª–∏–∑—É–µ–º –∑–Ω–∞—á–µ–Ω–∏—è (–ø—Ä–µ–¥–ø–æ–ª–∞–≥–∞–µ–º —á—Ç–æ –≤—Å–µ –∑–Ω–∞—á–µ–Ω–∏—è –æ—Ç 0 –¥–æ 1)
                    const points = values.map((value, index) => {
                        const angle = index * angleStep - Math.PI / 2;
                        const radius = Math.min(value, 1) * maxRadius; // –û–≥—Ä–∞–Ω–∏—á–∏–≤–∞–µ–º –º–∞–∫—Å–∏–º—É–º –µ–¥–∏–Ω–∏—Ü–µ–π
                        return {
                            x: centerX + Math.cos(angle) * radius,
                            y: centerY + Math.sin(angle) * radius
                        };
                    });

                    // –†–∏—Å—É–µ–º –∑–∞–ª–∏–≤–∫—É
                    ctx.fillStyle = colors[itemIndex] + '20'; // –î–æ–±–∞–≤–ª—è–µ–º –ø—Ä–æ–∑—Ä–∞—á–Ω–æ—Å—Ç—å
                    ctx.beginPath();
                    ctx.moveTo(points[0].x, points[0].y);
                    for (let i = 1; i < points.length; i++) {
                        ctx.lineTo(points[i].x, points[i].y);
                    }
                    ctx.closePath();
                    ctx.fill();

                    // –†–∏—Å—É–µ–º –∫–æ–Ω—Ç—É—Ä
                    ctx.strokeStyle = colors[itemIndex];
                    ctx.lineWidth = 2;
                    ctx.stroke();

                    // –†–∏—Å—É–µ–º —Ç–æ—á–∫–∏
                    ctx.fillStyle = colors[itemIndex];
                    points.forEach(point => {
                        ctx.beginPath();
                        ctx.arc(point.x, point.y, 4, 0, Math.PI * 2);
                        ctx.fill();
                    });
                });

                // –õ–µ–≥–µ–Ω–¥–∞
                const legendX = 20;
                let legendY = height - 120;
                
                ctx.font = '12px Arial';
                ctx.textAlign = 'left';
                ctx.fillStyle = '#333';
                ctx.fillText('–õ–µ–≥–µ–Ω–¥–∞:', legendX, legendY);
                legendY += 20;

                top5.forEach((item, index) => {
                    if (index >= colors.length) return;
                    
                    // –¶–≤–µ—Ç–Ω–æ–π –∫–≤–∞–¥—Ä–∞—Ç–∏–∫
                    ctx.fillStyle = colors[index];
                    ctx.fillRect(legendX, legendY - 8, 12, 12);
                    
                    // –ù–∞–∑–≤–∞–Ω–∏–µ
                    ctx.fillStyle = '#333';
                    const shortName = item.name.length > 25 ? item.name.substring(0, 25) + '...' : item.name;
                    ctx.fillText(shortName, legendX + 20, legendY + 2);
                    legendY += 18;
                });

            }, [data, width, height]);

            return <canvas ref={canvasRef} width={width} height={height} />;
        };

        // –ì–ª–∞–≤–Ω—ã–π –∫–æ–º–ø–æ–Ω–µ–Ω—Ç
        const MediaRatingDashboard = () => {
            const [data, setData] = useState([]);
            const [loading, setLoading] = useState(true);
            const [error, setError] = useState(null);
            const [viewMode, setViewMode] = useState('channels');
            const [selectedChannels, setSelectedChannels] = useState([]);
            const [availableChannels, setAvailableChannels] = useState([]);
            const [displayCount, setDisplayCount] = useState(10);

            useEffect(() => {
                const loadData = async () => {
                    try {
                        console.log('üîÑ –ù–∞—á–∏–Ω–∞–µ–º –∑–∞–≥—Ä—É–∑–∫—É Excel —Ñ–∞–π–ª–∞...');
                        
                        let response;
                        let arrayBuffer;
                        
                        try {
                            // –°–ø–æ—Å–æ–± 1: –æ–±—ã—á–Ω–∞—è –∑–∞–≥—Ä—É–∑–∫–∞ —Ñ–∞–π–ª–∞
                            response = await fetch('./calc_mts_v18_processed.xlsx');
                            if (response.ok) {
                                arrayBuffer = await response.arrayBuffer();
                                console.log('‚úÖ –§–∞–π–ª –∑–∞–≥—Ä—É–∂–µ–Ω —á–µ—Ä–µ–∑ fetch');
                            } else {
                                throw new Error(`HTTP ${response.status}: ${response.statusText}`);
                            }
                        } catch (fetchError) {
                            console.log('‚ùå Fetch –Ω–µ —Å—Ä–∞–±–æ—Ç–∞–ª:', fetchError.message);
                            
                            // –°–ø–æ—Å–æ–± 2: —á–µ—Ä–µ–∑ window.fs (Claude)
                            if (typeof window !== 'undefined' && window.fs && window.fs.readFile) {
                                console.log('üîÑ –ü—Ä–æ–±—É–µ–º window.fs.readFile...');
                                const fileData = await window.fs.readFile('calc_mts_v18_processed.xlsx');
                                arrayBuffer = fileData.buffer || fileData;
                                console.log('‚úÖ –§–∞–π–ª –∑–∞–≥—Ä—É–∂–µ–Ω —á–µ—Ä–µ–∑ window.fs');
                            } else {
                                throw new Error('Excel —Ñ–∞–π–ª –Ω–µ –Ω–∞–π–¥–µ–Ω. –£–±–µ–¥–∏—Ç–µ—Å—å, —á—Ç–æ —Ñ–∞–π–ª calc_mts_v18_processed.xlsx –Ω–∞—Ö–æ–¥–∏—Ç—Å—è –≤ —Ç–æ–π –∂–µ –ø–∞–ø–∫–µ —á—Ç–æ –∏ index.html');
                            }
                        }
                        
                        console.log(`üìä –†–∞–∑–º–µ—Ä —Ñ–∞–π–ª–∞: ${arrayBuffer.byteLength} –±–∞–π—Ç`);
                        
                        // –ü–∞—Ä—Å–∏–º Excel
                        const workbook = XLSX.read(arrayBuffer, {
                            cellStyles: true,
                            cellFormulas: true,
                            cellDates: true
                        });
                        
                        console.log('üìã –õ–∏—Å—Ç—ã –≤ —Ñ–∞–π–ª–µ:', workbook.SheetNames);
                        
                        const firstSheet = workbook.Sheets[workbook.SheetNames[0]];
                        const rawData = XLSX.utils.sheet_to_json(firstSheet, {header: 1});
                        
                        console.log(`üìà –°—Ç—Ä–æ–∫ –¥–∞–Ω–Ω—ã—Ö: ${rawData.length}`);
                        
                        // –û–±—Ä–∞–±–∞—Ç—ã–≤–∞–µ–º –¥–∞–Ω–Ω—ã–µ (–ø—Ä–æ–ø—É—Å–∫–∞–µ–º –∑–∞–≥–æ–ª–æ–≤–æ–∫)
                        const processedData = rawData.slice(1).map((row, index) => ({
                            channel: row[0],
                            format: row[1], 
                            duration: row[2],
                            trust: row[10] || 0,
                            passiveConsumption: row[11] || 0,
                            formatScore: row[12] || 0,
                            attentionShare: row[13] || 0,
                            contactTime: row[14] || 0,
                            momentaryClutter: row[15] || 0,
                            integralIndex: row[16] || 0
                        })).filter(item => item.channel && item.channel !== '');

                        console.log(`‚úÖ –û–±—Ä–∞–±–æ—Ç–∞–Ω–Ω—ã—Ö –∑–∞–ø–∏—Å–µ–π: ${processedData.length}`);
                        
                        setData(processedData);
                        
                        // –£–Ω–∏–∫–∞–ª—å–Ω—ã–µ –∫–∞–Ω–∞–ª—ã
                        const channels = [...new Set(processedData.map(item => item.channel))];
                        console.log(`üì∫ –£–Ω–∏–∫–∞–ª—å–Ω—ã—Ö –∫–∞–Ω–∞–ª–æ–≤: ${channels.length}`);
                        setAvailableChannels(channels);
                        setSelectedChannels(channels.slice(0, 5)); // –ü–æ —É–º–æ–ª—á–∞–Ω–∏—é –ø–µ—Ä–≤—ã–µ 5
                        
                        setLoading(false);
                        console.log('üéâ –î–∞–Ω–Ω—ã–µ —É—Å–ø–µ—à–Ω–æ –∑–∞–≥—Ä—É–∂–µ–Ω—ã!');
                        
                    } catch (error) {
                        console.error('‚ùå –û—à–∏–±–∫–∞ –∑–∞–≥—Ä—É–∑–∫–∏:', error);
                        setError(error.message);
                        setLoading(false);
                    }
                };
                
                loadData();
            }, []);

            const processedData = useMemo(() => {
                let filtered = data.filter(item => selectedChannels.includes(item.channel));
                
                if (viewMode === 'channels') {
                    // –ì—Ä—É–ø–ø–∏—Ä—É–µ–º –ø–æ –∫–∞–Ω–∞–ª–∞–º –∏ –≤—ã—á–∏—Å–ª—è–µ–º —Å—Ä–µ–¥–Ω–∏–µ
                    const channelGroups = {};
                    filtered.forEach(item => {
                        if (!channelGroups[item.channel]) {
                            channelGroups[item.channel] = {
                                channel: item.channel,
                                integralIndex: [],
                                trust: [],
                                passiveConsumption: [],
                                formatScore: [],
                                attentionShare: [],
                                contactTime: [],
                                momentaryClutter: []
                            };
                        }
                        channelGroups[item.channel].integralIndex.push(item.integralIndex);
                        channelGroups[item.channel].trust.push(item.trust);
                        channelGroups[item.channel].passiveConsumption.push(item.passiveConsumption);
                        channelGroups[item.channel].formatScore.push(item.formatScore);
                        channelGroups[item.channel].attentionShare.push(item.attentionShare);
                        channelGroups[item.channel].contactTime.push(item.contactTime);
                        channelGroups[item.channel].momentaryClutter.push(item.momentaryClutter);
                    });
                    
                    const aggregated = Object.values(channelGroups).map(group => ({
                        name: group.channel,
                        channel: group.channel,
                        integralIndex: group.integralIndex.reduce((a, b) => a + b, 0) / group.integralIndex.length,
                        trust: group.trust.reduce((a, b) => a + b, 0) / group.trust.length,
                        passiveConsumption: group.passiveConsumption.reduce((a, b) => a + b, 0) / group.passiveConsumption.length,
                        formatScore: group.formatScore.reduce((a, b) => a + b, 0) / group.formatScore.length,
                        attentionShare: group.attentionShare.reduce((a, b) => a + b, 0) / group.attentionShare.length,
                        contactTime: group.contactTime.reduce((a, b) => a + b, 0) / group.contactTime.length,
                        momentaryClutter: group.momentaryClutter.reduce((a, b) => a + b, 0) / group.momentaryClutter.length
                    }));
                    
                    return aggregated
                        .sort((a, b) => b.integralIndex - a.integralIndex)
                        .slice(0, displayCount);
                        
                } else if (viewMode === 'channel-format') {
                    return filtered
                        .map(item => ({
                            ...item,
                            name: `${item.channel} - ${item.format}`
                        }))
                        .sort((a, b) => b.integralIndex - a.integralIndex)
                        .slice(0, displayCount);
                } else {
                    return filtered
                        .map(item => ({
                            ...item,
                            name: `${item.channel} - ${item.format} (${item.duration}s)`
                        }))
                        .sort((a, b) => b.integralIndex - a.integralIndex)
                        .slice(0, displayCount);
                }
            }, [data, selectedChannels, viewMode, displayCount]);

            const handleChannelToggle = (channel) => {
                setSelectedChannels(prev => 
                    prev.includes(channel) 
                        ? prev.filter(c => c !== channel)
                        : [...prev, channel]
                );
            };

            if (loading) {
                return (
                    <div className="loading">
                        <div style={{fontSize: '24px', marginBottom: '10px'}}>‚è≥ –ó–∞–≥—Ä—É–∑–∫–∞ –¥–∞–Ω–Ω—ã—Ö...</div>
                        <div style={{fontSize: '16px', color: '#666'}}>–ß–∏—Ç–∞–µ–º Excel —Ñ–∞–π–ª calc_mts_v18_processed.xlsx</div>
                    </div>
                );
            }

            if (error) {
                return (
                    <div className="error">
                        <h3>‚ùå –û—à–∏–±–∫–∞ –∑–∞–≥—Ä—É–∑–∫–∏ –¥–∞–Ω–Ω—ã—Ö</h3>
                        <p><strong>–ü—Ä–æ–±–ª–µ–º–∞:</strong> {error}</p>
                        <div>
                            <p><strong>–í–æ–∑–º–æ–∂–Ω—ã–µ —Ä–µ—à–µ–Ω–∏—è:</strong></p>
                            <ul>
                                <li>–£–±–µ–¥–∏—Ç–µ—Å—å —á—Ç–æ —Ñ–∞–π–ª <code>calc_mts_v18_processed.xlsx</code> –∑–∞–≥—Ä—É–∂–µ–Ω –≤ GitHub</li>
                                <li>–§–∞–π–ª –¥–æ–ª–∂–µ–Ω –±—ã—Ç—å –≤ —Ç–æ–π –∂–µ –ø–∞–ø–∫–µ —á—Ç–æ –∏ <code>index.html</code></li>
                                <li>–ü—Ä–æ–≤–µ—Ä—å—Ç–µ —Ç–æ—á–Ω–æ—Å—Ç—å –Ω–∞–∑–≤–∞–Ω–∏—è —Ñ–∞–π–ª–∞</li>
                                <li>–í–æ–∑–º–æ–∂–Ω–æ –Ω—É–∂–Ω–æ –ø–æ–¥–æ–∂–¥–∞—Ç—å –Ω–µ—Å–∫–æ–ª—å–∫–æ –º–∏–Ω—É—Ç –¥–ª—è –æ–±–Ω–æ–≤–ª–µ–Ω–∏—è GitHub Pages</li>
                            </ul>
                        </div>
                        <button className="btn" onClick={() => window.location.reload()}>
                            üîÑ –ü–æ–ø—Ä–æ–±–æ–≤–∞—Ç—å —Å–Ω–æ–≤–∞
                        </button>
                    </div>
                );
            }

            return (
                <div className="container">
                    <h1 className="title">üìä –†–µ–π—Ç–∏–Ω–≥ –∫–∞—á–µ—Å—Ç–≤–∞ –º–µ–¥–∏–∞ –∫–∞–Ω–∞–ª–æ–≤</h1>
                    
                    {/* –ü–∞–Ω–µ–ª—å —É–ø—Ä–∞–≤–ª–µ–Ω–∏—è */}
                    <div className="card">
                        <div className="controls">
                            <div className="control-group">
                                <label className="label">–†–µ–∂–∏–º –æ—Ç–æ–±—Ä–∞–∂–µ–Ω–∏—è:</label>
                                <select 
                                    className="select"
                                    value={viewMode} 
                                    onChange={(e) => setViewMode(e.target.value)}
                                >
                                    <option value="channels">–¢–æ–ª—å–∫–æ –∫–∞–Ω–∞–ª—ã</option>
                                    <option value="channel-format">–ö–∞–Ω–∞–ª + –§–æ—Ä–º–∞—Ç</option>
                                    <option value="channel-format-duration">–ö–∞–Ω–∞–ª + –§–æ—Ä–º–∞—Ç + –î–ª–∏—Ç–µ–ª—å–Ω–æ—Å—Ç—å</option>
                                </select>
                            </div>
                            
                            <div className="control-group">
                                <label className="label">–ö–æ–ª–∏—á–µ—Å—Ç–≤–æ —ç–ª–µ–º–µ–Ω—Ç–æ–≤: {displayCount}</label>
                                <input
                                    className="range-input"
                                    type="range"
                                    min="5"
                                    max="30"
                                    value={displayCount}
                                    onChange={(e) => setDisplayCount(parseInt(e.target.value))}
                                />
                            </div>
                            
                            <div className="control-group">
                                <div className="info-text">
                                    –ü–æ–∫–∞–∑–∞–Ω–æ: {Math.min(displayCount, processedData.length)} –∏–∑ {processedData.length}<br/>
                                    –í—Å–µ–≥–æ –∑–∞–ø–∏—Å–µ–π: {data.length}
                                </div>
                            </div>
                        </div>

                        <div>
                            <label className="label">–í—ã–±–µ—Ä–∏—Ç–µ –∫–∞–Ω–∞–ª—ã:</label>
                            <div className="channels-grid">
                                {availableChannels.map(channel => (
                                    <label key={channel} className="checkbox-label">
                                        <input
                                            className="checkbox"
                                            type="checkbox"
                                            checked={selectedChannels.includes(channel)}
                                            onChange={() => handleChannelToggle(channel)}
                                        />
                                        <span title={channel}>{channel}</span>
                                    </label>
                                ))}
                            </div>
                        </div>
                    </div>

                    {/* –¢–∞–±–ª–∏—Ü–∞ —Ä–µ–π—Ç–∏–Ω–≥–æ–≤ */}
                    <div className="card">
                        <h2 className="card-title">üèÜ –¢–∞–±–ª–∏—Ü–∞ —Ä–µ–π—Ç–∏–Ω–≥–æ–≤</h2>
                        <div style={{overflowX: 'auto'}}>
                            <table className="table">
                                <thead>
                                    <tr>
                                        <th>–†–µ–π—Ç–∏–Ω–≥</th>
                                        <th>–ù–∞–∑–≤–∞–Ω–∏–µ</th>
                                        <th style={{textAlign: 'center'}}>–ò–Ω—Ç–µ–≥—Ä–∞–ª—å–Ω—ã–π –∏–Ω–¥–µ–∫—Å</th>
                                    </tr>
                                </thead>
                                <tbody>
                                    {processedData.map((item, index) => (
                                        <tr key={index}>
                                            <td className="rank">#{index + 1}</td>
                                            <td>{item.name}</td>
                                            <td className="index-score">
                                                {item.integralIndex.toFixed(3)}
                                            </td>
                                        </tr>
                                    ))}
                                </tbody>
                            </table>
                        </div>
                    </div>

                    {/* –ì—Ä–∞—Ñ–∏–∫–∏ */}
                    <div className="chart-container">
                        <div className="chart-card">
                            <h2 className="card-title">üìä –ò–Ω—Ç–µ–≥—Ä–∞–ª—å–Ω—ã–µ —Ä–µ–π—Ç–∏–Ω–≥–∏</h2>
                            <div className="canvas-container">
                                <BarChart data={processedData} width={600} height={400} />
                            </div>
                        </div>
                        
                        <div className="chart-card">
                            <h2 className="card-title">‚≠ê –°—Ä–∞–≤–Ω–µ–Ω–∏–µ —Ç–æ–ø-5 –ø–æ –∫—Ä–∏—Ç–µ—Ä–∏—è–º</h2>
                            <div className="canvas-container">
                                <RadarChart data={processedData} width={600} height={400} />
                            </div>
                        </div>
                    </div>

                    {/* –°—Ç–∞—Ç–∏—Å—Ç–∏–∫–∞ */}
                    <div className="card">
                        <h2 className="card-title">üìà –°—Ç–∞—Ç–∏—Å—Ç–∏–∫–∞</h2>
                        <div className="stats-grid">
                            <div className="stat-card blue">
                                <div className="stat-value blue">
                                    {selectedChannels.length}
                                </div>
                                <div className="stat-label">–í—ã–±—Ä–∞–Ω–æ –∫–∞–Ω–∞–ª–æ–≤</div>
                            </div>
                            <div className="stat-card green">
                                <div className="stat-value green">
                                    {data.filter(item => selectedChannels.includes(item.channel)).length}
                                </div>
                                <div className="stat-label">–í—Å–µ–≥–æ –∑–∞–ø–∏—Å–µ–π</div>
                            </div>
                            <div className="stat-card orange">
                                <div className="stat-value orange">
                                    {processedData.length > 0 ? processedData[0].integralIndex.toFixed(3) : '0.000'}
                                </div>
                                <div className="stat-label">–õ—É—á—à–∏–π —Ä–µ–π—Ç–∏–Ω–≥</div>
                            </div>
                            <div className="stat-card purple">
                                <div className="stat-value purple">
                                    {processedData.length > 0 ? 
                                        (processedData.reduce((sum, item) => sum + item.integralIndex, 0) / processedData.length).toFixed(3) 
                                        : '0.000'}
                                </div>
                                <div className="stat-label">–°—Ä–µ–¥–Ω–∏–π —Ä–µ–π—Ç–∏–Ω–≥</div>
                            </div>
                        </div>
                    </div>
                </div>
            );
        };

        ReactDOM.render(React.createElement(MediaRatingDashboard), document.getElementById('root'));
    </script>
</body>
</html>